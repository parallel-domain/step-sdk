syntax = "proto2";

import "pd_types.proto";
import "pd_distributions.proto";

package keystone;

/*
Wrapper which contains all parameters which that define scenario generation. Applied once per scenario.
*/
message UnifiedGeneratorParameters
{
  /*
  A list containing the atomic generators which will be applied to the scenario in scenario generation. At least
  one atomic generator is required for a scenario to be generated.
  */
  repeated AtomicGeneratorParameters atomics = 1;

  /*
  Flag which specifies where multiple scenarios will be batched into one scenario for rendering efficiency.
  */
  optional bool use_merge_batches = 2 [default = false];

  /*
  Field to allow defaults which apply across atomic generators to be overridden. If not provided, defaults within
  each atomic generator will be used.
  */
  optional DefaultAtomicGeneratorParameters default_params = 3;

  /*
  Field to allow map parameters to be modified. If not provided, default values of each map will be used.
  */
  optional EnvironmentParameters environment_params = 4;
}

/*
Parent type of each atomic generator
*/
message AtomicGeneratorParameters
{
  /*
  The type of atomic generator being specified. Must be specified.
  */
  oneof parameters {
    EgoAgentGeneratorParameters ego_agent = 1;
    VehicleGeneratorParameters vehicle = 2;
    TrafficGeneratorParameters traffic = 3;
    ParkedVehicleGeneratorParameters parked_vehicles = 4;
    StaticAgentGeneratorParameters static_agent = 5;
    DebrisGeneratorParameters debris = 6;
    PedestrianGeneratorParameters pedestrian = 7;
    RandomPedestrianGeneratorParameters random_pedestrian = 8;
    DroneGeneratorParameters drone = 9;
  }
}

/*
Contains default parameters applied to all atomics specified within :obj:`UnifiedGeneratorParameters`.
*/
message DefaultAtomicGeneratorParameters
{
  /*
  The default vehicle distribution which controls the types of vehicles that are spawned by atomic generators. If not
  provided, will use default values.
  */

  map<string, VehicleCategoryWeight> vehicle_distribution = 1;
}

/*
Parameters that modify map level attributes.
*/
message EnvironmentParameters
{
  /*
  Specifies the spawn probability of signs on  maps that begin with 'SIGNAGE_'. Must be a sit within 0.0 to 1.0. If
  not provided, will default to 0.
  */
  optional CenterSpreadConfig sign_spawn_probability = 1;

  /*
  Probability of spawning crosswalk signs in crosswalk signs location in or near crosswalks on maps that begin with
  'SIGNAGE_'. Must be a sit within 0.0 to 1.0. If not provided, will default to 0.
  */
  optional CenterSpreadConfig crosswalk_sign_spawn_probability = 2;

  /*
  Specifies road markings types across the map. If not provided, will default to the values below.

  Default values::

    "parking_spot_config"     {marker_type = MI_pavement_01, rgb = {1.0f, 1.0f, 1.0f}, wear = 0.0f}
    "parking_lot_marker"      {marker_type = "DOUBLE_SQUARE", rgb = {1.0f, 1.0f, 1.0f}, wear = 0.0f}
    "parallel_parking_marker" {rgb = {1.0f, 1.0f, 1.0f}, wear = 0.0f}
  */
  map<string, RoadMarkingData> marker_data_map = 3;

  /*
  Specifies the countries from which road signs should be spawned on ISA maps. If not provided, will use default
  values.

  Available options::

    "Austria"
    "Belgium"
    "Bulgaria"
    "Croatia"
    "Cyprus"
    "Czechia"
    "Denmark"
    "Estonia"
    "Finland"
    "France"
    "Germany"
    "Greece"
    "Hungary"
    "Ireland"
    "Italy"
    "Latvia"
    "Lithuania"
    "Luxembourg"
    "Malta"
    "Netherlands"
    "Norway"
    "Poland"
    "Portugal"
    "Romania"
    "Slovakia"
    "Slovenia"
    "Spain"
    "Sweden"
    "Switzerland"
  */
  optional EnumDistribution region = 4;

  /*
  Parameters which control the placement of parking spaces on maps. If not specified, will use defaults.
  */
  optional ParkingSpaceData parking_space_data = 5;
}

/*
Parameters that configure parking space placement on maps.
*/
message ParkingSpaceData
{
  /*
  Desired parking space angle for parking lots in degrees and its associated probability. Does not apply to street
  parking spaces. If not provided, will use defaults.

  Valid angles are::

    "ANGLE_30"
    "ANGLE_45"
    "ANGLE_60"
    "PERPENDICULAR"
  */
  optional EnumDistribution parking_lot_angle_distribution = 1;

  /*
  Specifies delineation type for parking lot spaces and its associated probability. If not provided, will use defaults.

  Valid values::

    "SINGLE_DASHED"
    "DOUBLE_OPEN"
    "DOUBLE_SQUARED"
    "DOUBLE_ROUND"
    "T_SHAPE"
    "NO_LINE"
    "BOX_CLOSED"
    "BOX_OPEN_CURB"
    "BOX_DOUBLE"
    "SINGLE_SQUARED_OPEN_CURB"
    "DOUBLE_ROUND_50CM_GAP"
    "DOUBLE_ROUND_50CM_GAP_OPEN_CURB"
    "DOUBLE_SQUARED_50CM_GAP_OPEN_CURB"
    "T_FULL"
    "T_SHORT"
   */
  optional EnumDistribution lot_parking_delineation_type = 2;

  /*
  Specifies delineation type for non parallel street parking spaces. If not provided, will use default value of
  `SINGLE`.

  Valid values::

    "SINGLE"
    "DASHED"
    "DOUBLE_OPEN"
    "DOUBLE_SQUARED"
    "DOUBLE_ROUND"
    "T_SHAPE"
    "NO_LINE"
    "BOX_CLOSED"
    "BOX_OPEN_CURB"
    "BOX_DOUBLE"
    "SINGLE_SQUARED_OPEN_CURB"
    "DOUBLE_ROUND_50CM_GAP"
    "DOUBLE_ROUND_50CM_GAP_OPEN_CURB"
    "DOUBLE_SQUARED_50CM_GAP_OPEN_CURB"
    "T_FULL"
    "T_SHORT"
   */
  optional EnumDistribution street_parking_delineation_type = 3;

  /*
  Specifies delineation type for parallel street parking spaces. If not provided, will use default value selected in
  :obj:`street_parking_delineation_type`.

  Valid values::

    "SINGLE"
    "DASHED"
    "DOUBLE_OPEN"
    "DOUBLE_SQUARED"
    "DOUBLE_ROUND"
    "T_SHAPE"
    "NO_LINE"
    "UNMETERED"
    "BOX_CLOSED"
    "BOX_OPEN_CURB"
    "BOX_DOUBLE"
    "SINGLE_SQUARED_OPEN_CURB"
    "DOUBLE_ROUND_50CM_GAP"
    "DOUBLE_ROUND_50CM_GAP_OPEN_CURB"
    "DOUBLE_SQUARED_50CM_GAP_OPEN_CURB"
    "T_FULL"
    "T_SHORT"
  */
  optional EnumDistribution street_parking_angle_zero_override = 4;

  /*
  Specifies the color of all parking lines in RGB format. If not provided, will default to white.
  */
  repeated Float3 delineation_color = 5;

  /*
  Specifies the level of wear on all parking slot lines. A value of 0.0 is fully unworn and 1.0 is fully worn.
  If not provided, will use value of 0.25.
  */
  optional CenterSpreadConfig delineation_wear_amount = 6;

  /*
  The type of parking slot ground material which should be applied to the map, and their associated probability values.
  If not provided, defaults to `MI_pavement_01`.

  Valid Values::

    "MI_pavement_01"
    "MI_ParkingTiles_BrickBasket_01"
    "MI_ParkingTiles_BrickHerring_01"
    "MI_ParkingTiles_BrickHex_01"
    "MI_ParkingTiles_BrickOrnate_01"
    "MI_ParkingTiles_CobbleStone_01"
    "MI_ParkingTiles_CobbleStone_02"
    "MI_ParkingTiles_ConcreteBrick_01"
    "MI_ParkingTiles_ConcreteBrick_02"
    "MI_ParkingTiles_ConcreteBrick_03"
    "MI_ParkingTiles_ConcretePavers_01"
    "MI_ParkingTiles_StoneFlag_01"
  */
  optional EnumDistribution parking_space_material = 7;

  /*
  Specifies the tint of all parking slot surfaces in RGB format. If not provided, will default to un-tinted.
  */
  repeated Float3 parking_space_tint = 8;

  /*
  Specifies the level of grunge applied to all parking slot surfaces. A value of 0.0 is free of grunge and 1.0 applies
  maximum grunge to parking slots.	If not provided, will use value of 0.25.
  */
  optional CenterSpreadConfig parking_space_grunge_amount = 9;

  /*
  Specifies the level of wear on all parking slot decals. A value of 0.0 is fully unworn and 1.0 is fully worn.
  If not provided, will use value of 0.25.
  */
  optional CenterSpreadConfig global_parking_decal_wear = 10;

  /*
  Parameter that specifies the types and probabilities of decals that should be applied to parking slots.
  */
  optional ObjectDecorationParams parking_space_decoration = 11;
}

/*
Parameters which specify the appearance of road markings on the map.
*/
message RoadMarkingData
{
  /*
  Flag to specify whether to use default RGB values. Not yet implemented.
  */
  optional bool use_preset = 1 [default = false];

  /*
  Specify an RGB value (each channel from 0.0 to 1.0) for all road markings in the map. If not provided, will use
  default values.
  */
  repeated FloatArray override_colors = 2;

  /*
  Specifies which colors in the asset registry to use for road markings used if :attr:`use_preset` is set to `True`.
  Not yet implemented, will currently have no effect.
  */
  repeated string preset_colors = 3;

  /*
  Specifies a marker name, and corresponds to the key as listed in :obj:`marker_data_map`. If not provided, will use
  default values in :obj:`marker_data_map`.

  Valid values::

    "Single"
    "Dashed"
    "Double Open"
    "Double Squared"
    "Double Round"
    "T"
    "MI_pavement_01"
    "MI_ParkingTiles_BrickBasket_01"
    "MI_ParkingTiles_BrickHerring_01"
    "MI_ParkingTiles_BrickHex_01"
    "MI_ParkingTiles_BrickOrnate_01"
    "MI_ParkingTiles_CobbleStone_01"
    "MI_ParkingTiles_CobbleStone_02"
    "MI_ParkingTiles_ConcreteBrick_01"
    "MI_ParkingTiles_ConcreteBrick_02"
    "MI_ParkingTiles_ConcreteBrick_03"
    "MI_ParkingTiles_ConcretePavers_01"
    "MI_ParkingTiles_StoneFlag_01
  */
  repeated string marker_types = 4;

  /*
  Specifies the level of wear applied to road markings. Ranges from 0.0 to 1.0 where 0.0 is fully unworn and 1.0 is
  fully worn. If not provided, will default to 0.0.
  */
  optional CenterSpreadConfig wear = 5;
}

/*
Specifies the name of a parking slot decal decoration to be applied.
*/
message DecorationPreset
{
  /*
  The name of the parking slot decal decoration. Must be provided.
   */
  required string preset_name = 1;

  /*
  Specifies which variant of the parking slot decal decoration should be used.
  */
  optional uint32 variant = 2 [default = 0];
}

/*
Metadata of parking slot decal decorations.
*/
message DecorationData
{
  oneof decoration_data
  {
    DecorationPreset decoration_preset = 1;
  }
}

/*
Message which specifies the link between an object in the world and the decoration that is applied to it (eg. a parking
slot decal decoration).
*/
message ObjectDecorations
{
  /*
  The id of the object to which the decoration should be applied.
  */
  required uint32 object_id = 1;

  /*
  Parameters specifying the decoration which should be applied to the object.
  */
  required DecorationData decoration_data = 2;
}

/*
Parameters which control the placement of decorations on an object.
*/
message ObjectDecorationParams
{
  /*
  The probability that a decoration will be applied to a particular object.
  */
  optional float decorate_chance = 1 [default = 0.1];

  /*
  The distribution of which decorations should be applied to a particular object and their associated probabilities.
  If not provided, will use default values.

  Valid values::

    "None"
    "TAXI_text"
    "TAXI_icon"
    "NO_PARKING_text"
    "LOADING_ZONE_text"
    "EV_JP_01_A_icon"
    "EV_JP_01_B_icon"
    "EV_JP_01_C_icon"
    "EV_01_icon"
    "EV_02_icon"
    "EV_03_icon"
    "Family_01_A_icon"
    "Family_01_B_icon"
    "Family_01_C_icon"
    "PARKING_10_MIN_text"
    "PARKING_30_MIN_text"
    "PARKING_15_MIN_text"
    "RESERVED_01_text"
    "Wheelchair_01_A_icon"
    "Wheelchair_01_B_icon"
    "Wheelchair_01_C_icon"
    "Wheelchair_01_D_icon"
   */
  optional EnumDistribution preset_distribution = 2;
}

/*
Message to store array of RGB values.
*/
message FloatArray
{
  repeated float data = 1;
}

/*
Generator to place an ego agent with sensor in the world. Required for every scenario. All agents placed by the
EgoAgentGenerator will have an "EGO" tag added by default.
*/
message EgoAgentGeneratorParameters
{

  /*
  Determines the type of agent that the ego sensor is attached to.
  */
  optional AgentType agent_type = 1 [default = VEHICLE];

  /*
  Specifies the type of agent which the ego will be attached to is :attr:`agent_type` if :obj:`AgentType.VEHICLE`.
  */
  optional string ego_model = 2 [default = "suv_medium_02"];

  /*
  Specify the location on the map at which the ego agent will be spawned. Must be provided.
  */
  optional PositionRequest position_request = 3;

  /*
  Specifies if the ego agent should be placed in front of a traffic light at the beginning of a scenario.
  */
  optional bool use_traffic_light_color_probability = 4 [default = false];

  /*
  Specifies the desired traffic light distribution (with associated probability) to use if
  :attr:`use_traffic_light_color_probability` is True. Must be provided if :attr:`use_traffic_light_color_probability`
  is True.

  Possible values::

    "Red"
    "Yellow"
    "Green"
  */
  optional EnumDistribution traffic_light_color_probability = 5;

  /*
  Specifies parameters of the ego agent if :attr:`agent_type` is :obj:`AgentType.VEHICLE`. If not provided, will use
  defaults specified in `VehicleSpawnData`.
  */
  optional VehicleSpawnData vehicle_spawn_data = 6;

  /*
  DEPRECATED
  */
  optional PedestrianSpawnData pedestrian_spawn_data = 7;

  /*
  DEPRECATED
  */
  optional DroneSpawnData drone_spawn_data = 8;
}

/*
Collection of currently supported agent types. Only :obj:`AgentType.VEHICLE` is currently supported.
*/
enum AgentType
{
  /*
  DEPRECATED
  */
  UNSPECIFIED = 0;

  /*
  Vehicle that follows the road network with physical body movement.
  */
  VEHICLE = 1;

  /*
  DEPRECATED
  */
  PARKED_VEHICLE = 2;

  /*
  DEPRECATED
  */
  TRAILER_VEHICLE = 3;

  /*
  DEPRECATED
  */
  PEDESTRIAN = 4;

  /*
  DEPRECATED
  */
  STATIC_OBJECT = 5;

  /*
  DEPRECATED
  */
  DRONE = 6;

  /*
  DEPRECATED
  */
  ANIMAL = 7;
}

/*
Places a single non-ego vehicle into the world. Requires previous use of :obj:`EgoAgentGeneratorParameters` in the
scenario.
*/
message VehicleGeneratorParameters
{
  /*
  Name of the vehicle asset that should be spawned. Must be provided.
  */
  optional string model = 1;

  /*
  Specifies the location at which the vehicle should be spawned. Must be provided.
  */
  optional PositionRequest position_request = 2;

  /*
  Parameters that govern the vehicle's spawn characteristics and movement behavior. If not provided, will use
  defaults specified in :obj:`VehicleSpawnData`.
  */
  optional VehicleSpawnData vehicle_spawn_data = 3;
}

/*
Generator to place multiple vehicles into the world. Requires previous use of :obj:`EgoAgentGeneratorParameters` in the
scenario.
*/
message TrafficGeneratorParameters
{
  /*
  Specifies the location around which traffic agents should be spawned. Only works with
  :obj:`LocationRelativePositionRequest`. Must be provided.
  */
  optional PositionRequest position_request = 1;

  /*
  Specifies the density of traffic that is spawned by controlling the proportion of valid spawn points in which
  vehicles are spawned. Valid values are floats in the range 0.0 to 1.0. 0.0 indicates
  no traffic spawned. 1.0 indicates maximum possible density.
  */
  optional float spawn_probability = 2 [default = 0.8];

  /*
  Parameters that govern the vehicle's spawn characteristics and movement behavior. If not provided, will use
  defaults specified in :obj:`VehicleSpawnData`.
  */
  optional VehicleSpawnData vehicle_spawn_data = 3;

  /*
  Specifies the likelihood of various vehicle categories spawning. If not provided, will use the values below.

  Default values::

    "MIDSIZE" : 0.181
    "COMPACT" : 0.177
    "BUS" : 0.019
    "TRUCK" : 0.038
    "SUV" : 0.197
    "VAN" : 0.066
    "BICYCLE" : 0.061
    "MOTORCYCLE" :  0.068
    "CARAVAN" :/RV  0.009
    "FULLSIZE" :  0.184
  */
  map<string, VehicleCategoryWeight> vehicle_distribution = 4;

  /*
  Controls the minimum separation distance between valid spawn points for vehicles by multiplying the
  `start_separation_time_map` by each vehicle's initial velocity. If not provided, defaults to the values below.

  Default values::

    {"bicycle", {0.7f, 1.7f}}
    {"heavy", {2.5f, 3.5f}}
    {"heavy_nondriven", {2.5f, 3.5f}}
    {"light", {0.7f, 1.7f}}
    {"light_nondriven", {0.7f, 1.7f}}
    {"medium", {1.5f, 2.5f}}
    {"medium_nondriven", {1.5f, 2.5f}}
    {"motorcycle", {0.7f, 1.7f}}
   */
  map<string, ContinousUniformDistribution> start_separation_time_map = 5;

  /*
  Specifies the separation time between vehicles which should be targeted through the scenario. If not provided, will
  use the values provided in :attr:`start_separation_time_map`.
  */
  map<string, ContinousUniformDistribution> target_separation_time_map = 6;
}

/*
Generator to place parked vehicles in the scenario. Requires previous use of :obj:`EgoAgentGeneratorParameters` in the
scenario.
*/
message ParkedVehicleGeneratorParameters
{
  /*
  Specifies the location around which traffic should be spawned. Only works with
  :obj:`LocationRelativePositionRequest`. Must be provided.
  */
  optional PositionRequest position_request = 1;

  /*
  Specifies the density of parked vehicles that is spawned by controlling the proportion of valid spawn points in which
  vehicles are spawned. Valid values are floats in the range 0.0 to 1.0. 0.0 indicates
  no traffic spawned. 1.0 indicates maximum possible density. If not provided, will use default value of 0.
  */
  optional CenterSpreadConfig spawn_probability = 2;

  /*
  Specifies the likelihood of various vehicle categories spawning. If not provided, will use the values below.

  Default values::

    "MIDSIZE" : 0.181
    "COMPACT" : 0.177
    "BUS" : 0.019
    "TRUCK" : 0.038
    "SUV" : 0.197
    "VAN" : 0.066
    "BICYCLE" : 0.061
    "MOTORCYCLE" :  0.068
    "CARAVAN" :/RV  0.009
    "FULLSIZE" :  0.184
  */
  map<string, VehicleCategoryWeight> vehicle_distribution = 3;

  /*
  Specifies spawn data which applies to the agents spawned by this generator. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 4;
}

/*
Generator to place a static agent in the world. Requires previous use of :obj:`EgoAgentGeneratorParameters` in the
scenario.
*/
message StaticAgentGeneratorParameters
{
  /*
  Specifies the location around which traffic should be spawned.
  */
  optional PositionRequest position_request = 1;

  /*
  The asset name of the static agent which should be spawned. Must be provided.
  */
  optional string model = 2;

  /*
  Specifies spawn data which applies to the agents spawned by this generator. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 3;
}

/*
Generator to place debris in the scenario. Requires previous use of :obj:`EgoAgentGeneratorParameters` in the
scenario.
*/
message DebrisGeneratorParameters
{
  /*
  Specifies the density of debris that is spawned by controlling the proportion of valid spawn points in which
  debris are spawned. Valid values are floats in the range 0.0 to 1.0. 0.0 indicates
  no debris spawned. 1.0 indicates maximum possible density.
  */
  optional float spawn_probability = 1 [default = 0.01];

  /*
  Determines the lateral bias of debris placement within lanes. Valid values are in the range -1.0 to 1.0. A value
  of 1.0 will bias debris placement to the center of the lane. A value of -1.0 will bias debris placement to the
  edges of the lane. A value of 0.0 will evenly place debris throughout the lane.

  If not provided, a value of 0.0 will be used
  */
  optional float debris_center_bias = 2;

  /*
  Specifies the minimum distance from the ego that debris is spawned. Must be a float greater than 0.0. If not
  provided, will use value of 0.0.
  */
  optional float min_debris_distance = 3;

  /*
  Specifies the maximum distance from the ego that debris is spawned. Must be a float greater than 0.0.
  */
  optional float max_debris_distance = 4 [default = 50.0];

  /*
  Comma separated string which lists the assets to be spawn as debris. Every asset has an equal spawn probability.
  */
  optional string debris_asset_tag = 5 [default = "trash_bottle_tall_01"];

  /*
  Comma separated string which lists debris assets that appear in :attr:`debris_asset_tag` which should be skipped
  and not spawned. If not provided, no assets are removed from :attr:`debris_asset_tag`.
  */
  optional string debris_asset_remove_tag = 6;

  /*
  Specifies the location around which traffic should be spawned. Only works with
  :obj:`LocationRelativePositionRequest` and :obj:`LaneSpawnPolicy`. Must be provided.
  */
  optional PositionRequest position_request = 7;

  /*
  Specifies the asset names that should be spawned as debris together with their associated spawn probability. If
  provided, asset names in :attr:`debris_asset_tag` and :attr:`debris_asset_remove_tag` are ignored.
  */
  map<string, float> asset_distribution = 8;

  /*
  Specifies spawn data which applies to the agents spawned by this generator. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 9;
}

/*
Generator to place a single pedestrian in the scenario. Requires previous use of :obj:`EgoAgentGeneratorParameters` in
the scenario.
*/
message PedestrianGeneratorParameters
{
  /*
  Specifies the location around which traffic should be spawned. Works with all `PositionRequest` types except
  :obj:`PathTimeRelativePositionRequest`.
  */
  optional PositionRequest position_request = 1;

  /*
  Specifies parameters that control pedestrian spawning and movement behavior. If not provided, will use defaults
  specified in :obj:`PedestrianSpawnData`.
  */
  optional PedestrianSpawnData ped_spawn_data = 2;
}

/*
Generator to place multiple pedestrians in a scenario. Requires previous use of :obj:`EgoAgentGeneratorParameters` in
the scenario.
*/
message RandomPedestrianGeneratorParameters
{
  /*
  Specifies the minimum and maximum values for the speed of each pedestrian. Each spawned pedestrian's speed is then
  randomly sampled from this range. The specified `min` value must be greater than 0.0 and the specified `max` value
  must be greater than `min`.

  If not provided, will use a `min` of 0.5 and a `max` of 1.5.
  */
  optional MinMaxConfigFloat speed_range = 1;

  /*
  Specifies the location around which traffic should be spawned. Only works with
  :obj:`LocationRelativePositionRequest` and :obj:`LaneSpawnPolicy`. Must be provided.
  */
  optional PositionRequest position_request = 2;

  /*
  Specifies the minimum and maximum number of pedestrians to generate. The actual number of pedestrians to spawn is
  selected from a normal distribution within this range. The specified `min` value must be greater than 0.0 and the
  specified `max` value must be greater than `min`. This parameter must be provided.
  */
  optional MinMaxConfigInt num_of_pedestrians_range = 3;

  /*
  Specified the spatial separation between pedestrians in meters. Specified values must be greater than 0.0.
  */
  optional float min_radius_between_pedestrians = 4 [default = 0.5];

  /*
  Specifies parameters that control pedestrian spawning and movement behavior. If not provided, will use defaults
  specified in :obj:`PedestrianSpawnData`.
  */
  optional PedestrianSpawnData ped_spawn_data = 5;
}

/*
Not yet implemented.
*/
message DroneGeneratorParameters
{
  /*
  Not yet implemented.
  */
  optional PositionRequest position_request = 1;

  /*
  Not yet implemented.
  */
  optional DroneSpawnData drone_spawn_data = 2;
}



/*
Specifies a location in the world which can be used to govern object placement.
*/
message PositionRequest
{
  /*
  Specifies the distance in meters to move along a lane after an initial is found within the :obj:`PositionRequest`.
  Can be any float: positive values will move forwards along the lane and negative values will move backwards along
  the lane. If not provided, will default to 0.0.
  */
  optional CenterSpreadConfig longitudinal_offset = 1;

  /*
  Specifies the distance in meters to move laterally (relative to a lane) after an initial is found within the
  :obj:`PositionRequest`. Can be any float: positive values will move rightwards in the lane and negative values will
  move leftwards in the lane. If not provided, will default to 0.0.
  */
  optional CenterSpreadConfig lateral_offset = 2;

  /*
  Specifies a rotation of the returned position about the up axis of the world. The rotation is specified in radians
  and is aligned with the right hand rule for rotation about the up axis. Rotation is applied about the center of the
  object. If not specified, will use a value of 0.0.
  */
  optional CenterSpreadConfig yaw_offset = 3;

  /*
  Specifies a type of methodology to find and return a position. The position returned from this request is then used
  as the base position to which :attr:`longitudinal_offset`, :attr:`lateral_offset` and :attr:`yaw_offset` are applied.
  */
  oneof position_type
  {
    /*
    Position request that specifies an x,y,z position in the world.
    */
    AbsolutePositionRequest absolute_position_request = 4;

    /*
    Position request that specifies a time to "path-crossing" between agents.
    */
    PathTimeRelativePositionRequest path_time_relative_position_request = 5;

    /*
    Position request that specifies a location relative to another agent.
    */
    LocationRelativePositionRequest location_relative_position_request = 6;

    /* Position request that returns a location in a specified lane.
    */
    LaneSpawnPolicy lane_spawn_policy = 7;

    /*
    DEPRECATED
    */
    RoadPitchPositionRequest road_pitch_position_request = 8;
  }
}

/*
Policy to return a spawn location based on the curvature of lanes around the spawn location.
*/
message LaneCurvatureSpawnPolicy
{
  /*
  Specifies the minimum and maximum values for the curvature of lane segments when searching for valid spawn locations.
  If not provided, will use default values.
  */
  optional MinMaxConfigFloat curvature_bounds = 1;

  /*
  Specifies a minimum length in meters for the lane on which the returned spawn location is located.
  */
  optional float min_section_length = 2;
}

/*
Policy to return a spawn location based on proximity to a junction.
*/
message JunctionSpawnPolicy
{
  /*
  Specifies a desired range of distances from the spawn location and the junction. The distance between the returned
  spawn point and the junction will be randomly samples from this distribution. Specified values must be greater than
  0.0. If not provided, will revert to default.
  */
  optional ContinousUniformDistribution distance_to_junction = 1;

  /*
  Flag to control whether to use specified intersection type probabilities.
  */
  optional bool use_intersection_type_probability = 2 [default = false];

  /*
  Specifies distribution for intersection types (with associated probability) to use if
  :attr:`use_intersection_type_probability` is `True`. Must be provided if
  :attr:`use_intersection_type_probability` is `True`.

  Valid values::

    "Signaled"
    "Signed"
  */
  optional EnumDistribution intersection_type_probability = 3;
}

/*
Specifies a type of policy to be applied when spawning agents on a lane.
*/
message PositionOfInterestPolicy
{
  /*
  The spawn policy which should be applied
  */
  oneof PositionOfInterestType
  {
    LaneCurvatureSpawnPolicy lane_curvature_spawn_policy = 1;
    JunctionSpawnPolicy junction_spawn_policy = 2;
  }
}

/*
Returns a location based on an exact coordinate system. Note that when a vehicle agent is placed using an Absolute
Position Request, the vehicle may not be placed in the exact position specified by the user.

The vehicle will be placed in the center of, and aligned with, the lane which is closest to the position requested
by the user, as long as the initially requested position falls within a drivable lane.

If a :attr:`lane_id` is provided, the vehicle will be placed in the center of, and aligned with, that lane, 
regardless of what position is requested inside the Absolute Position Request.
*/
message AbsolutePositionRequest
{
  /*
  `x`, `y`, `z` coordinates in world coordinates of the position desired.
  */
  optional Float3 position = 1;

  /*
  3x3 Rotation matrix which specifies the rotation of the returned location. If not provided, rotation will be
  determined by the lane underneath the specified :attr:`position`.
  */
  optional Float3x3 rotation = 2;

  /*
  Specify the id of a lane on which the position should be returned. If no id is provided, the lane id will be
  inferred from the :attr:`position` specified.
  In cases where the lane is inferred, the lane will be inferred from one of the following lane types::

    "Drivable"
    "Sidewalk"
    "Parking"
    "ParkingAisle"
    "ParkingSpace"
  */
  optional uint64 lane_id = 3;


  /*
  Flag to control whether the `z` value of the returned location is automatically resolved. If set to `True`, the
  returned `z` location will be the ground location of the specified `x` and `y` in :attr:`position`. If set to
  `False`, the returned `z` location will be that specified in :attr:`position`.

  If not provided, will be set to `True`.
  */
  optional bool resolve_z = 4;
}

/*
Generator to place an agent in a position and path that will cause it to intersect with another agent's path at a
specified time.

Only works on `DRIVABLE` lanes and requires the agent with which an intersecting path is desired to the placed first.
*/
message PathTimeRelativePositionRequest
{

  /*
  The tag(s) of the agent(s) with which the agent being placed should intersect paths with.
  */
  repeated string agent_tags = 1;

  /*
  The time in seconds required for the agent being placed to intersect with the agent(s) specified in
  :attr:`agent_tags`. The minimum and maximum of a continuous distribution must be specified and the returned
  time_to_path will be randomly sampled from this distribution.

  If not provided, will default to 0. If both :attr:`time_to_path` and :attr:`time_along_path` are 0,
  a :attr:`PositionRequest.longitudinal_offset` and/or :attr:`PositionRequest.lateral_offset` must be specified.
  */
  optional ContinousUniformDistribution time_to_path = 2;

  /*
  Time for agent(s) specified by agent_tag to reach intersection point. The minimum and maximum of a continuous
  distribution must be specified and the returned time_along_path will be randomly sampled from this distribution.

  If not provided, will default to 0. If both :attr:`time_to_path` and :attr:`time_along_path` are 0,
  a :attr:`PositionRequest.longitudinal_offset` and/or :attr:`PositionRequest.lateral_offset` must be specified.
  */
  optional ContinousUniformDistribution time_along_path = 3;

  /*
  Specifies the angle at which the paths of the agent being placed and the agent(s) specified in :attr:`agent_tags`
  cross. Angle is specified in radians in the form of the minimums and maximums of a continuous uniform distribution.
  If not provided, paths can cross at any angle.
  */
  optional ContinousUniformDistribution incident_angle = 4;
}

/*
Returns a location in a position relative to a tagged agent. Requires the tagged agent to be placed first.
*/
message LocationRelativePositionRequest
{
  /*
  The tag(s) of the agent(s) relative to which the returned location should be calculated.
  */
  repeated string agent_tags = 1;

  /*
  The maximum radius in meters from the agent in :attr:`agent_tags` the returned location can exist. Any value greater
  than 0.0 can be specified.

  */
  optional float max_spawn_radius = 2 [default = 150];

  /*
  Specifies a lane criteria on which the returned location can exist. If not provided, no restrictions are placed on
  what lane type the returned location can exist on.
  */
  optional LaneSpawnPolicy lane_spawn_policy = 3;
}

/*
Specifies a lane type (or multiple) on which a location can be returned.
*/
message LaneSpawnPolicy
{
  /*
  Specifies the minimum number of lanes that should exist in the same direction on the road on which the returned
  location is located. Must be an integer greater than 0. If not provided, will use 0.
  */
  optional int32 min_num_lanes_in_same_direction = 1;

  /*
  Specifies the lane types on which the returned location should exist and their associated probabilities.

  Valid lane types are::

    "Drivable"
    "NonDrivable"
    "Parking"
    "Shoulder"
    "Biking"
    "Crosswalk"
    "ParkingAisle"
    "ParkingSpace"
    "Sidewalk"
  */
  optional EnumDistribution lane_type = 2;

  /*
  Specifies the minimum number of lanes that should exist in the opposite direction on the road on which the returned
  location is located. Must be an integer greater than 0.
  */
  optional int32 min_num_lanes_in_opposite_direction = 3 [default = 0];

  /*
  Specifies the lateral offset in lanes of the returned location. Values in the range from -1.0 to 1.0 are valid.
  Negative values offset to the left of the lane, positive values to the right. If not provided, will use 0.0.
  */
  optional CenterSpreadConfig lateral_offset = 4;

  /*
  Flag to specify if bicycles should only be spawned in bike lanes.
  */
  optional bool bicycles_only_in_bike_lanes = 5 [default = true];

  /*
  Specifies a policy which controls assets near which the returned location should be located.
  */
  optional NearbyAssetPolicy nearby_asset_policy = 6;

  /*
  Specifies the road types on which the returned location should exist and their associated probabilities. If not
  provided, no restrictions are placed on the type of road on which a returned location can be located.

  Valid values::

    "Motorway"
    "Residential"
    "Trunk"
    "Primary"
    "Secondary"
    "Tertiary"
    "Unclassified"
    "Motorway_Link"
    "Truck_Link"
    "Primary_Link"
    "Secondary_Link"
    "Tertiary_Link"
    "Service"
    "Driveway"
    "Parking_Aisle"
    "Driveway_Parking_Entry"
  */
  optional EnumDistribution road_type = 7;

  /*
  Specifies a policy which controls the proximity of a returned location to a particular position of interest.
  */
  repeated PositionOfInterestPolicy position_of_interest_policy = 8;

  /*
  Specifies the minimum length (in meters) of the path (ahead of the spawn location) on which the returned location
  exists. `min_path_length` is specified as a `CenterSpreadConfig` with a minimum and maximum value. The exact
  `min_path_length` for a returned location will be randomly sampled from this distribution.

  This parameter does not have an effect if spawning in a driveway, parking aisle or parking space. If not provided,
  200.0 will be used.
  */
  optional CenterSpreadConfig min_path_length = 9;

  /*
  Specifies the minimum length (in meters) of the path (behind the spawn location) on which the returned location
  exists. `min_path_length` is specified as a `CenterSpreadConfig` with a minimum and maximum value. The exact
  `min_path_length` for a returned location will be randomly sampled from this distribution.

  This parameter does not have an effect if spawning in a driveway, parking aisle or parking space. If not provided,
  100.0 will be used.
  */
  optional CenterSpreadConfig min_length_behind = 10;

  /*
  Specifies the type of parking spaces which should exist on stree parking spaces if a location on street parking
  spaces is returned by this `LaneSpawnPolicy`. Parking space types for parking spaces in lots are specified in
  :obj:`ParkingSpaceData`.

  Valid values::

    "PARALLEL"
    "ANGLE_30"
    "ANGLE_45"
    "ANGLE_60"
    "PERPENDICULAR"

  */
  optional EnumDistribution on_road_parking_angle_distribution = 11;

  /*
  Specifies the distribution of lane decorations and their associated probabilities if object decorations are enabled.
  If not provided, no lane decorations are applied. See :obj:`ObjectDecorationParams` for list of valid values.
  */
  optional EnumDistribution lane_decoration_distribution = 12;
}

/*
Selects a location based on the difference in slope of the road on either side of the returned location.
*/
message RoadPitchPositionRequest
{
  /*
  Specifies the desired difference in pitch angle (in radians) which should exist in the road segments on either
  side of the returned location. The desired pitch is specified as a :obj:`ContinousUniformDistribution` which is
  randomly sampled from in searching for a location to return.
  */
  optional ContinousUniformDistribution road_pitch = 1;

  /*
  Specifies a policy for the types of lanes on which a location can be returned.
  */
  optional LaneSpawnPolicy lane_spawn_policy = 2;

  /*
  Flag to control whether the specified :attr:`road_pitch` distribution is split into bins when sampled.
  This results in a more even distribution of pitches when the `RoadPitchPositionRequest` is called multiple times.
  */
  optional bool bin_pitch_points = 3 [default = true];

  /*
  When :attr:`bin_pitch_points` is `True`, specifies the width in radians of the each bin.
  */
  optional float bin_width = 4 [default = 0.0087];
}

/*
Policy that allows for spawn placement to be near a specified asset.
*/
message NearbyAssetPolicy
{
  /*
  The radius from the asset specified in :attr:`asset_tags` within which the policy should return a location.
  Radius is specified as a :obj:`CenterSpreadConfig` which is randomly sampled from during scenario generation.
  */
  optional CenterSpreadConfig search_radius = 1;

  /*
  The number of assets to spawn, specified as a :obj:`MinMaxConfigInt` which is randomly sampled from during
  scenario generation.
  */
  optional MinMaxConfigInt num_assets = 2;

  /*
  The names of assets that the policy should return positions near to, subject to the parameters in
  :attr:`search_radius`.
  */
  repeated string asset_tags = 3;
}

/*
Parameters to controls a vehicle's spawn characteristics and movement behavior.
*/
message VehicleSpawnData
{
  /*
  Parameters to control the movement behavior of a vehicle. If not provided, will default to default
  values in :obj:`VehicleBehavior`.
  */
  optional VehicleBehavior vehicle_behavior = 1;

  /*
  Parameters that control vehicle peripherals (eg. accessories, color, occupants, etc.). If not provided, will default
  to default values in :obj:`VehiclePeripheral`.
  */
  optional VehiclePeripheral vehicle_peripheral = 2;

  /*
  Specifies spawn data which applies to the agents. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 3;
}

/*
Parameters which direct a vehicle's movement behavior (eg. lane change, speed, etc.).

Note that in some cases, the Vehicle Behavior exhibited in the simulation may differ from that which the user has directed.
Vehicle Behavior is affected by obstacles near the vehicle, curvature of the road, end-of-lanes the vehicle is
approaching and the slope of the road.
*/
message VehicleBehavior
{
  /*
  Specifies the start speed of a vehicle at the beginning of a scenario. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution start_speed = 1;

  /*
  Specifies the target speed of the vehicle. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.

  Will not cause vehicle to exceed the speed limit of a road unless :attr:`ignore_speed_limit` is set to `True`.
  */
  optional ContinousUniformDistribution target_speed = 2;

  /*
  Flag to control whether vehicle will ignore speed limits in attempting to achieve the :attr:`target_speed`.
  */
  optional bool ignore_speed_limit = 3 [default = false];

  /*
  Specifies the lateral offset of the vehicle in the vehicle's motion plan relative to lane center line. Possible
  values are floats from -1.0 to 1.0, and represent the proportion of the lane's half width to offset laterally.
  Positive values offset to the right and negative values offset to the left. Offset distance is capped so vehicle
  does not protrude laterally out of the lane edges.

  If not provided, will default to 0.0. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution lane_offset = 4;

  /*
  Controls the frequency of weaving within the vehicle's lanes during travel. Weaving is modelled as a perlin noise
  driven wave. If not provided, will default to 0.0. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution lane_drift_scale = 5;

  /*
  Controls the amplitude of weaving within the vehicle's lanes during travel. Weaving is modelled as a perlin noise
  driven wave. If not provided, will default to 0.0. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution lane_drift_amplitude = 6;

  /*
  Specifies the probability that a vehicle will make a lane change.
  Evaluated once every second. If evaluated to true, vehicle will lane change if conditions allow
  (having lanes to change to, no obstables in those lanes or in lane change path)
  Values can range from 0.0 to 1.0. If not provided, defaults to zero. Value is specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution lane_change_probability = 7;

  /*
  Specifies the time in seconds during which another lane change cannot occur after the vehicle undergoes a lane
  change. If not provided, a default value of 10 is used. Value is specified as a
  ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution lane_change_cooldown = 8;

  /*
  Boolean flag to specify whether lane change decisions are made dynamically while the scenario is being simulated.
  */
  optional bool enable_dynamic_lane_selection = 9 [default = false];

  /*
  Specifies the gear that the vehicle should start in at the beginning of scenario generation.
  */
  optional Gear start_gear = 10 [default = DRIVE];

  /*
  Specifies the spacing, in seconds, that should exist between vehicles in the same lane at the start of the scenario.
  Value is specified as a :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution start_separation_time = 11;

  /*
  Specifies the spacing, in seconds, that targeted between vehicles in the same lane over the course of the scenario.
  Value is specified as a :obj:`ContinousUniformDistribution` which is randomly sampled from during scenario generation.
  */
  optional ContinousUniformDistribution target_separation_time = 12;

  /*
  Specifies a float measurement of the level of aggression with which the vehicle should drive. Impacts values such
  as lane change speed, abruptness of turns. Also multiplies the set :attr:`target_speed` to define the speed that
  will be targeted by the vehicle during the scenario.

  Must be a float greater than 0.0 if specified. If not specified, a default value is used.
  */
  optional ContinousUniformDistribution vehicle_aggression = 13;

  /*
  Specifies a list of :obj:`ObstacleType` that the vehicle should ignore in driving.
  */
  repeated ObstacleType ignore_obstacle_types = 14;

  /*
  Specifies the goal position for the vehicle to target in a parking/unparking scenario. Only
  :obj:`AbsolutePositionRequest` and :obj:`LaneSpawnPolicy` position request types are supported.

  Must be provided if a parking/unparking scenario is desired. Will result in a scenario with standard vehicle
  driving behavior if not provided.

  To specify a parking scenario, set a `lane_spawn_policy` that specifies a `ParkingSpace` as the goal. To control
  whether the parking occurs in a parking lot or on the street, specify a `road_type` within the `lane_spawn_policy`
  as appropriate.

  To specify an unparking scenario, set a :obj:`position_request` in the generator to a `LaneSpawnPolicy` that
  specifies a parking space, and use this :attr:`parking_scenario_goal` to specify only a `road_type` that corresponds
  to the type of road the vehicle should exit onto. Unparking is not supported on streets.

  Examples::

  >>> # Parking in Parking Lot
  >>> {
  >>>    lane_spawn_policy: {
  >>>        lane_type: {
  >>>            probabilities: {
  >>>                "ParkingSpace": 1.0
  >>>            }
  >>>        },
  >>>        road_type: {
  >>>            probabilities: {
  >>>                "Parking_Aisle": 1.0
  >>>            }
  >>>        }
  >>>    }
  >>> }
  >>>
  >>> # Parking on street
  >>> {
  >>>     lane_spawn_policy: {
  >>>         lane_type: {
  >>>             probabilities: {
  >>>                 "ParkingSpace": 1.0
  >>>             }
  >>>         },
  >>>         road_type: {
  >>>             probabilities: {
  >>>                 "Primary": 1.0
  >>>             }
  >>>         }
  >>>     }
  >>> }
  >>>
  >>> # Unparking in Parking Lot
  >>> {
  >>>     lane_spawn_policy: {
  >>>         lane_type: {
  >>>             probabilities: {
  >>>                 "ParkingSpace": 1.0
  >>>             }
  >>>         },
  >>>         road_type: {
  >>>             probabilities: {
  >>>                 "ParkingAisle": 1.0
  >>>             }
  >>>         }
  >>>     }
  >>> }
  */
  optional PositionRequest parking_scenario_goal = 15;

  /*
  Specifies the time (in seconds) it takes to reach the end of the parking maneuver assuming constant acceleration
  from the initial speed to the targe speed. Does not account for vehicle slow downs due to obstacles etc. If not
  provided, will use a value 5s.
  */
  optional ContinousUniformDistribution parking_scenario_time = 16;
}

/*
Specifies and controls parameters of a vehicle's peripherals (eg. accessory data, color, occupants, etc.).
*/
message VehiclePeripheral
{
  /*
  The probability that the vehicle will be spawned with an attached articulated trailer. Must be a float in the range
  of 0.0 to 1.0.
  */
  optional float spawn_trailer_probability = 1 [default = 0];

  /*
  The angle, in radians, that an articulated trailer will be spawned at relative to the ego vehicle. Specified as a
  :obj:`ContinousUniformDistribution` which is randomly sampled from at scenario generation.
  */
  optional ContinousUniformDistribution trailer_initial_yaw = 2;

  /*
  Boolean flag to control whether vehicle occupants are disabled.
  */
  optional bool disable_occupants = 3 [default = false];

  /*
  Boolean flag to control whether vehicles are spawned with accessories.
  */
  optional bool disable_accessories = 4 [default = false];

  /*
  Boolean flag to control whether vehicle accessories have randomized colors.
  */
  optional bool randomize_vehicle_parts = 5 [default = true];

  /*
  Probability that emergency lights are on for vehicles that are equipped with emergency lights.
  */
  optional float emergency_light_probability = 6 [default = 0.5];

  /*
  Boolean flag to control whether headlight on/off states are controlled by the time of day of the scenario. If
  `True`, headlights will turn on in dark time of day scenarios. If `False`, :attr:`headlight_probability` is used to
  determine headlight on/off state.
  */
  optional bool set_headlight_based_on_time_of_day = 7 [default = true];

  /*
  Controls the probability that headlights are turned on if :attr:`set_headlight_based_on_time_of_day` is `False`.
  Ignored if :attr:`set_headlight_based_on_time_of_day` is `True`.
  */
  optional float headlight_probability = 8 [default = 0.0];
}

/*
Enum containing different obstacle types.
*/
enum ObstacleType
{
  ROUTE_LENGTH = 0;
  REVERSE_DISTANCE = 1;
  PATH_END = 2;
  FORWARD_AGENT = 3;
  ONCOMING_AGENT = 4;
  END_OF_LANE = 5;
  BLOCKED_LANE = 6;
  MERGE = 7;
  LINEAR_MOVER = 8;
  LANE_CLOSURE = 9;
  CROSSTRAFFIC = 10;
  STOP_LINE = 11;
}

/*
Enum containing the different types of vehicle transmission gears.
*/
enum Gear
{
  PARKED = 1;
  REVERSE = 2;
  NEUTRAL = 3;
  DRIVE = 4;
}

/*
Parameters to control a pedestrian's spawn characteristics and movement behavior.
*/
message PedestrianSpawnData
{
  /*
  Specifies probability of overriding color of pedestrian's clothes to RGB color specified by
  :attr:`pedestrian_color_override_rgb`. Probability is specified as a `CenterSpreadConfig` with values in the range
  0.0 to 1.0, and is randomly sampled from during scenario generation. If not provided, will default to 0.0.
  */
  optional CenterSpreadConfig pedestrian_color_override_probability = 1;

  /*
  Specifies color to override pedestrian's clothes with if a pedestrian will have its clothing color overridden
  based on :attr:`pedestrian_color_override_probability`. Specified as `RGB` values in the range 0.0 to 1.0.
  */
  optional Float3 pedestrian_color_override_rgb = 2;

  /*
  DEPRECATED - Specifies whether pedestrian should use dynamic path planning, if `True``, determines path to take
  during scenario generation and can change depending on location. If `False``, pedestrians use a predetermined path
  to take during scenario generation.
  */
  optional bool pedestrians_dynamic_pathing = 3 [default = true, deprecated = true];

  /*
  Boolean flag to specify whether pedestrians always face the direction of travel.
  */
  optional bool orient_to_velocity = 4 [default = true];

  /*
  Boolean flag to specify whether spawn locations are checked for occupancy by other agents prior to spawning.
  */
  optional bool check_occupancy = 5 [default = true];

  /*
  Specifies how far ahead, in meters, a jaywalking pedestrian should be from the tagged vehicle. If
  :attr:`ped_behavior` does not specify that the pedestrian is a `JAYWALKER`, this field is ignored.
  */
  optional float jaywalker_ego_fwd_offset = 6 [default = 20.0];

  /*
  Specifies spawn data which applies to the agents. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 7;

  /*
  Specifies desired behavior of pedestrian being spawned. If not provided, will default to `NORMAL` behavior.
  */
  optional PedestrianBehavior ped_behavior = 8;

  /*
  Asset name of the pedestrian being spawned.
  */
  optional string asset_name = 9 [default = "char_hannah_001"];

  /*
  Specifies the speed in meters per second of the pedestrian being spawned.
  */
  optional float speed = 10 [default = 1.0];
}

/*
Contains parameter that governs and controls pedestrian behavior.
*/
enum PedestrianBehavior
{
  /*
  Behavior where pedestrian will walk on sidewalks/crosswalks and only cross roads at crosswalks.

  Note than pedestrians will attempt to walk to a random position in the pedestrian lane on which they are located.
  Upon reaching this goal, another goal will be selected at random.

  Pedestrians will attempt to walk only on pedestrians surfaces.  If a pedestrian is not placed on a pedestrian 
  surface, it will attempt to take a direct line to the nearest pedestrian surface.

  Pedestrians will attempt to avoid static objects and be biased to walking in the center of pedestrian lanes.
  */
  NORMAL = 1;

  /*
  Behavior where pedestrian will stay in place at spawn location.
  */
  STATIC = 2;

  /*
  Behavior where pedestrian will exhibit jaywalking behavior (eg. cross the road at a non-crosswalk).
  */
  JAYWALKER = 3;

  /*
  Behavior where pedestrian will spawn on sidewalk, walk towards agent and stop at edge of sidewalk.
  */
  EDGESTOPPER = 4;
}

/*
Parameters to control a drone's spawn characteristics and movement behavior.
*/
message DroneSpawnData
{
  /*
  Specify the probability that the drone will ascend (as opposed to descend). Specified as a float in the range 0.0
  to 1.0.
  */
  optional float ascend_probability = 1 [default = 0.5];

  /*
  Probability of having a ground asset directly below the lowest point of the drone's flight path.
  */
  optional float ground_asset_probability = 2 [default = 0.5];

  /*
  List of ground assets to choose from if a ground asset should be spawned based on the parameter
  :attr:`ground_asset_probability`.
  */
  repeated string ground_assets = 3;

  /*
  Directory where flight path csv files are stored within the instance. If not provided, default flight path shape
  is used.
  */
  optional string flight_path_dir = 4;

  /*
  Specifies spawn data which applies to the agents. If not provided, will default to default
  values in :obj:`AgentSpawnData`.
  */
  optional AgentSpawnData agent_spawn_data = 5;

  /*
  Specifies the vertical distance, in meters, between the lowest point of the drone flight path and the ground.
  Specified as a :obj:`ContinousUniformDistribution` which is randomly sampled from at scenario generation.
  */
  optional ContinousUniformDistribution height_offset = 6;

  /*
  Specifies the vertical distance above the ground which the ground asset should be spawned at if a ground asset
  should be spawned according to parameters in :attr:`ground_asset_probability`.

  Specified as a :obj:`ContinousUniformDistribution` which is randomly sampled from at scenario generation.
  */
  optional ContinousUniformDistribution ground_asset_height_offset = 7;
}

/*
Contains spawn metadata that applies across agent types.
*/
message AgentSpawnData
{
  /*
  Tags to be applied to the agent. Tags are case sensitive.
  */
  repeated string tags = 1;
}

/*
DEPRECATED
 */
enum SpecialAgentTag
{
  EGO = 0;
  STAR = 1;
}

/*
Specifies distribution of bulb colors in the traffic signal lights.
*/
message SignalLightDistribution
{
  optional float green = 1 [default = 0.3333];
  optional float red = 2 [default = 0.3333];
  optional float yellow = 3 [default = 0.3333];
}

/*
Specifies distribution of turns types of incoming lanes in a junction.
*/
message TurnTypeDistribution
{
  optional float straight = 1 [default = 0.3333];
  optional float left = 2 [default = 0.3333];
  optional float right = 3 [default = 0.3333];
}
/*
Specifies distribution of parking types present in the map.
*/
message ParkingTypeDistribution
{
  optional float forward = 1 [default = 0.5];
  optional float reverse = 2 [default = 0.5];
  optional float parallel = 3 [default = 0.0];
}
/*
Specifies probability distribution defined by center and spread.
*/
message CenterSpreadProbabilityConfig
{
  optional float probability = 1 [default = 0.0];
  optional float center = 2 [default = 0.0];
  optional float spread = 3 [default = 0.0];
}
/*
Specifies center and spread of distribution defined with float values.
*/
message CenterSpreadConfig
{
  optional float center = 1 [default = 0.0];
  optional float spread = 2 [default = 0.0];
}
/*
Specifies center and spread of distribution defined with integer values.
*/
message CenterSpreadConfigInt
{
  optional int32 center = 1 [default = 0];
  optional int32 spread = 2 [default = 0];
}
/*
Specifies lower and upper bounds of distributions defined with float values.
*/
message MinMaxConfigFloat
{
  optional float min = 1 [default = 0.0];
  optional float max = 2 [default = 0.0];
}
/*
Specifies lower and upper bounds of distributions defined with integer values.
*/
message MinMaxConfigInt
{
  optional int32 min = 1 [default = 0];
  optional int32 max = 2 [default = 0];
}

